import { __decorate, __param } from "tslib";
import { ComponentFactoryResolver, ComponentRef, Directive, ElementRef, Inject, Input, OnDestroy, OnInit, Optional, Self, TemplateRef, ViewContainerRef, EmbeddedViewRef } from '@angular/core';
import { AbstractControl, ControlContainer, NgControl, ValidationErrors } from '@angular/forms';
import { DefaultControlErrorComponent } from './control-error.component';
import { ControlErrorAnchorDirective } from './control-error-anchor.directive';
import { EMPTY, fromEvent, merge, NEVER, Subject } from 'rxjs';
import { ErrorTailorConfigProvider, FORM_ERRORS } from './providers';
import { distinctUntilChanged, mapTo, startWith, switchMap, takeUntil } from 'rxjs/operators';
import { FormActionDirective } from './form-action.directive';
let ControlErrorsDirective = class ControlErrorsDirective {
    constructor(vcr, resolver, host, config, globalErrors, controlErrorAnchorParent, form, ngControl, controlContainer) {
        this.vcr = vcr;
        this.resolver = resolver;
        this.host = host;
        this.config = config;
        this.globalErrors = globalErrors;
        this.controlErrorAnchorParent = controlErrorAnchorParent;
        this.form = form;
        this.ngControl = ngControl;
        this.controlContainer = controlContainer;
        this.customErrors = {};
        this.controlErrorsOnAsync = true;
        this.controlErrorsOnBlur = true;
        this.destroy = new Subject();
        this.showError$ = new Subject();
        this.mergedConfig = {};
        this.submit$ = this.form ? this.form.submit$ : EMPTY;
        this.reset$ = this.form ? this.form.reset$ : EMPTY;
        this.mergedConfig = this.buildConfig();
    }
    ngOnInit() {
        this.anchor = this.resolveAnchor();
        this.control = (this.controlContainer || this.ngControl).control;
        const hasAsyncValidator = !!this.control.asyncValidator;
        const statusChanges$ = this.control.statusChanges.pipe(distinctUntilChanged());
        const valueChanges$ = this.control.valueChanges;
        const controlChanges$ = merge(statusChanges$, valueChanges$);
        let changesOnAsync$ = EMPTY;
        let changesOnBlur$ = EMPTY;
        if (this.controlErrorsOnAsync && hasAsyncValidator) {
            // hasAsyncThenUponStatusChange
            changesOnAsync$ = statusChanges$.pipe(startWith(true));
        }
        if (this.controlErrorsOnBlur && this.isInput) {
            const blur$ = fromEvent(this.host.nativeElement, 'focusout');
            // blurFirstThenUponChange
            changesOnBlur$ = blur$.pipe(switchMap(() => valueChanges$.pipe(startWith(true))));
        }
        const submit$ = merge(this.submit$.pipe(mapTo(true)), this.reset$.pipe(mapTo(false)));
        // when submitted, submitFirstThenUponChanges
        const changesOnSubmit$ = submit$.pipe(switchMap(submit => (submit ? controlChanges$.pipe(startWith(true)) : NEVER)));
        // on reset, clear ComponentRef and customAnchorDestroyFn
        this.reset$.pipe(takeUntil(this.destroy)).subscribe(() => this.clearRefs());
        merge(changesOnAsync$, changesOnBlur$, changesOnSubmit$, this.showError$)
            .pipe(takeUntil(this.destroy))
            .subscribe(() => this.valueChanges());
    }
    setError(text, error) {
        if (!this.ref) {
            const factory = this.resolver.resolveComponentFactory(this.mergedConfig.controlErrorComponent);
            this.ref = this.anchor.createComponent(factory);
        }
        const instance = this.ref.instance;
        if (this.controlErrorsTpl) {
            instance.createTemplate(this.controlErrorsTpl, error, text);
        }
        else {
            instance.text = text;
        }
        if (this.controlErrorsClass) {
            instance.customClass = this.controlErrorsClass;
        }
        if (!this.controlErrorAnchor && this.mergedConfig.controlErrorComponentAnchorFn) {
            this.customAnchorDestroyFn = this.mergedConfig.controlErrorComponentAnchorFn(this.host.nativeElement, this.ref.hostView.rootNodes[0]);
        }
    }
    /**
     * Explicit showing of a control error via some custom application code.
     */
    showError() {
        this.showError$.next();
    }
    /**
     * Explicit hiding of a control error via some custom application code.
     */
    hideError() {
        this.setError(null);
    }
    ngOnDestroy() {
        this.destroy.next();
        this.clearRefs();
    }
    get isInput() {
        return this.mergedConfig.blurPredicate(this.host.nativeElement);
    }
    clearRefs() {
        if (this.customAnchorDestroyFn) {
            this.customAnchorDestroyFn();
            this.customAnchorDestroyFn = null;
        }
        if (this.ref) {
            this.ref.destroy();
        }
        this.ref = null;
    }
    valueChanges() {
        const controlErrors = this.control.errors;
        if (controlErrors) {
            const [firstKey] = Object.keys(controlErrors);
            const getError = this.customErrors[firstKey] || this.globalErrors[firstKey];
            if (!getError) {
                return;
            }
            const text = typeof getError === 'function' ? getError(controlErrors[firstKey]) : getError;
            if (this.isInput) {
                this.host.nativeElement.parentElement.classList.add('error-tailor-has-error');
            }
            this.setError(text, controlErrors);
        }
        else if (this.ref) {
            if (this.isInput) {
                this.host.nativeElement.parentElement.classList.remove('error-tailor-has-error');
            }
            this.setError(null);
        }
    }
    resolveAnchor() {
        if (this.controlErrorAnchor) {
            return this.controlErrorAnchor.vcr;
        }
        if (this.controlErrorAnchorParent) {
            return this.controlErrorAnchorParent.vcr;
        }
        return this.vcr;
    }
    buildConfig() {
        return Object.assign({
            blurPredicate(element) {
                return element.tagName === 'INPUT' || element.tagName === 'SELECT';
            },
            controlErrorComponent: DefaultControlErrorComponent
        }, this.config);
    }
};
ControlErrorsDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [ErrorTailorConfigProvider,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [FORM_ERRORS,] }] },
    { type: ControlErrorAnchorDirective, decorators: [{ type: Optional }] },
    { type: FormActionDirective, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: ControlContainer, decorators: [{ type: Optional }, { type: Self }] }
];
__decorate([
    Input('controlErrors')
], ControlErrorsDirective.prototype, "customErrors", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsClass", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsTpl", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsOnAsync", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsOnBlur", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorAnchor", void 0);
ControlErrorsDirective = __decorate([
    Directive({
        selector: '[formControlName]:not([controlErrorsIgnore]), [formControl]:not([controlErrorsIgnore]), [formGroup]:not([controlErrorsIgnore]), [formGroupName]:not([controlErrorsIgnore]), [formArrayName]:not([controlErrorsIgnore]), [ngModel]:not([controlErrorsIgnore])',
        exportAs: 'errorTailor'
    }),
    __param(3, Inject(ErrorTailorConfigProvider)),
    __param(4, Inject(FORM_ERRORS)),
    __param(5, Optional()),
    __param(6, Optional()),
    __param(7, Optional()), __param(7, Self()),
    __param(8, Optional()), __param(8, Self())
], ControlErrorsDirective);
export { ControlErrorsDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC1lcnJvci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L2Vycm9yLXRhaWxvci8iLCJzb3VyY2VzIjpbImxpYi9jb250cm9sLWVycm9yLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLHdCQUF3QixFQUN4QixZQUFZLEVBQ1osU0FBUyxFQUNULFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUNMLFNBQVMsRUFDVCxNQUFNLEVBQ04sUUFBUSxFQUNSLElBQUksRUFDSixXQUFXLEVBQ1gsZ0JBQWdCLEVBQ2hCLGVBQWUsRUFDaEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNoRyxPQUFPLEVBQUUsNEJBQTRCLEVBQXlCLE1BQU0sMkJBQTJCLENBQUM7QUFDaEcsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDL0UsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDM0UsT0FBTyxFQUFxQix5QkFBeUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBTyxNQUFNLGdCQUFnQixDQUFDO0FBQ25HLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBUTlELElBQWEsc0JBQXNCLEdBQW5DLE1BQWEsc0JBQXNCO0lBa0JqQyxZQUNVLEdBQXFCLEVBQ3JCLFFBQWtDLEVBQ2xDLElBQWdCLEVBQ21CLE1BQXlCLEVBQ3ZDLFlBQVksRUFDckIsd0JBQXFELEVBQ3JELElBQXlCLEVBQ2pCLFNBQW9CLEVB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QTtJQUNWLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLElBQUksRUFBRSxDQUFBO0lBQ2xCLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLElBQUksRUFBRSxDQUFBO0dBM0JWLHNCQUFzQixDQWdMbEM7U0FoTFksc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICBDb21wb25lbnRSZWYsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBTZWxmLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgRW1iZWRkZWRWaWV3UmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBDb250cm9sQ29udGFpbmVyLCBOZ0NvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEZWZhdWx0Q29udHJvbEVycm9yQ29tcG9uZW50LCBDb250cm9sRXJyb3JDb21wb25lbnQgfSBmcm9tICcuL2NvbnRyb2wtZXJyb3IuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnRyb2xFcnJvckFuY2hvckRpcmVjdGl2ZSB9IGZyb20gJy4vY29udHJvbC1lcnJvci1hbmNob3IuZGlyZWN0aXZlJztcbmltcG9ydCB7IEVNUFRZLCBmcm9tRXZlbnQsIG1lcmdlLCBORVZFUiwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRXJyb3JUYWlsb3JDb25maWcsIEVycm9yVGFpbG9yQ29uZmlnUHJvdmlkZXIsIEZPUk1fRVJST1JTIH0gZnJvbSAnLi9wcm92aWRlcnMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcFRvLCBzdGFydFdpdGgsIHN3aXRjaE1hcCwgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBGb3JtQWN0aW9uRGlyZWN0aXZlIH0gZnJvbSAnLi9mb3JtLWFjdGlvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRXJyb3JzTWFwIH0gZnJvbSAnLi90eXBlcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjpcbiAgICAnW2Zvcm1Db250cm9sTmFtZV06bm90KFtjb250cm9sRXJyb3JzSWdub3JlXSksIFtmb3JtQ29udHJvbF06bm90KFtjb250cm9sRXJyb3JzSWdub3JlXSksIFtmb3JtR3JvdXBdOm5vdChbY29udHJvbEVycm9yc0lnbm9yZV0pLCBbZm9ybUdyb3VwTmFtZV06bm90KFtjb250cm9sRXJyb3JzSWdub3JlXSksIFtmb3JtQXJyYXlOYW1lXTpub3QoW2NvbnRyb2xFcnJvcnNJZ25vcmVdKSwgW25nTW9kZWxdOm5vdChbY29udHJvbEVycm9yc0lnbm9yZV0pJyxcbiAgZXhwb3J0QXM6ICdlcnJvclRhaWxvcidcbn0pXG5leHBvcnQgY2xhc3MgQ29udHJvbEVycm9yc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgQElucHV0KCdjb250cm9sRXJyb3JzJykgY3VzdG9tRXJyb3JzOiBFcnJvcnNNYXAgPSB7fTtcbiAgQElucHV0KCkgY29udHJvbEVycm9yc0NsYXNzOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIEBJbnB1dCgpIGNvbnRyb2xFcnJvcnNUcGw6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG4gIEBJbnB1dCgpIGNvbnRyb2xFcnJvcnNPbkFzeW5jID0gdHJ1ZTtcbiAgQElucHV0KCkgY29udHJvbEVycm9yc09uQmx1ciA9IHRydWU7XG4gIEBJbnB1dCgpIGNvbnRyb2xFcnJvckFuY2hvcjogQ29udHJvbEVycm9yQW5jaG9yRGlyZWN0aXZlO1xuXG4gIHByaXZhdGUgcmVmOiBDb21wb25lbnRSZWY8Q29udHJvbEVycm9yQ29tcG9uZW50PjtcbiAgcHJpdmF0ZSBhbmNob3I6IFZpZXdDb250YWluZXJSZWY7XG4gIHByaXZhdGUgc3VibWl0JDogT2JzZXJ2YWJsZTxFdmVudD47XG4gIHByaXZhdGUgcmVzZXQkOiBPYnNlcnZhYmxlPEV2ZW50PjtcbiAgcHJpdmF0ZSBjb250cm9sOiBBYnN0cmFjdENvbnRyb2w7XG4gIHByaXZhdGUgZGVzdHJveSA9IG5ldyBTdWJqZWN0KCk7XG4gIHByaXZhdGUgc2hvd0Vycm9yJCA9IG5ldyBTdWJqZWN0KCk7XG4gIHByaXZhdGUgbWVyZ2VkQ29uZmlnOiBFcnJvclRhaWxvckNvbmZpZyA9IHt9O1xuICBwcml2YXRlIGN1c3RvbUFuY2hvckRlc3Ryb3lGbjogKCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSBob3N0OiBFbGVtZW50UmVmLFxuICAgIEBJbmplY3QoRXJyb3JUYWlsb3JDb25maWdQcm92aWRlcikgcHJpdmF0ZSBjb25maWc6IEVycm9yVGFpbG9yQ29uZmlnLFxuICAgIEBJbmplY3QoRk9STV9FUlJPUlMpIHByaXZhdGUgZ2xvYmFsRXJyb3JzLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgY29udHJvbEVycm9yQW5jaG9yUGFyZW50OiBDb250cm9sRXJyb3JBbmNob3JEaXJlY3RpdmUsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBmb3JtOiBGb3JtQWN0aW9uRGlyZWN0aXZlLFxuICAgIEBPcHRpb25hbCgpIEBTZWxmKCkgcHJpdmF0ZSBuZ0NvbnRyb2w6IE5nQ29udHJvbCxcbiAgICBAT3B0aW9uYWwoKSBAU2VsZigpIHByaXZhdGUgY29udHJvbENvbnRhaW5lcjogQ29udHJvbENvbnRhaW5lclxuICApIHtcbiAgICB0aGlzLnN1Ym1pdCQgPSB0aGlzLmZvcm0gPyB0aGlzLmZvcm0uc3VibWl0JCA6IEVNUFRZO1xuICAgIHRoaXMucmVzZXQkID0gdGhpcy5mb3JtID8gdGhpcy5mb3JtLnJlc2V0JCA6IEVNUFRZO1xuICAgIHRoaXMubWVyZ2VkQ29uZmlnID0gdGhpcy5idWlsZENvbmZpZygpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5hbmNob3IgPSB0aGlzLnJlc29sdmVBbmNob3IoKTtcbiAgICB0aGlzLmNvbnRyb2wgPSAodGhpcy5jb250cm9sQ29udGFpbmVyIHx8IHRoaXMubmdDb250cm9sKS5jb250cm9sO1xuICAgIGNvbnN0IGhhc0FzeW5jVmFsaWRhdG9yID0gISF0aGlzLmNvbnRyb2wuYXN5bmNWYWxpZGF0b3I7XG5cbiAgICBjb25zdCBzdGF0dXNDaGFuZ2VzJCA9IHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgY29uc3QgdmFsdWVDaGFuZ2VzJCA9IHRoaXMuY29udHJvbC52YWx1ZUNoYW5nZXM7XG4gICAgY29uc3QgY29udHJvbENoYW5nZXMkID0gbWVyZ2Uoc3RhdHVzQ2hhbmdlcyQsIHZhbHVlQ2hhbmdlcyQpO1xuICAgIGxldCBjaGFuZ2VzT25Bc3luYyQ6IE9ic2VydmFibGU8YW55PiA9IEVNUFRZO1xuICAgIGxldCBjaGFuZ2VzT25CbHVyJDogT2JzZXJ2YWJsZTxhbnk+ID0gRU1QVFk7XG5cbiAgICBpZiAodGhpcy5jb250cm9sRXJyb3JzT25Bc3luYyAmJiBoYXNBc3luY1ZhbGlkYXRvcikge1xuICAgICAgLy8gaGFzQXN5bmNUaGVuVXBvblN0YXR1c0NoYW5nZVxuICAgICAgY2hhbmdlc09uQXN5bmMkID0gc3RhdHVzQ2hhbmdlcyQucGlwZShzdGFydFdpdGgodHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbnRyb2xFcnJvcnNPbkJsdXIgJiYgdGhpcy5pc0lucHV0KSB7XG4gICAgICBjb25zdCBibHVyJCA9IGZyb21FdmVudCh0aGlzLmhvc3QubmF0aXZlRWxlbWVudCwgJ2ZvY3Vzb3V0Jyk7XG4gICAgICAvLyBibHVyRmlyc3RUaGVuVXBvbkNoYW5nZVxuICAgICAgY2hhbmdlc09uQmx1ciQgPSBibHVyJC5waXBlKHN3aXRjaE1hcCgoKSA9PiB2YWx1ZUNoYW5nZXMkLnBpcGUoc3RhcnRXaXRoKHRydWUpKSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Ym1pdCQgPSBtZXJnZSh0aGlzLnN1Ym1pdCQucGlwZShtYXBUbyh0cnVlKSksIHRoaXMucmVzZXQkLnBpcGUobWFwVG8oZmFsc2UpKSk7XG5cbiAgICAvLyB3aGVuIHN1Ym1pdHRlZCwgc3VibWl0Rmlyc3RUaGVuVXBvbkNoYW5nZXNcbiAgICBjb25zdCBjaGFuZ2VzT25TdWJtaXQkID0gc3VibWl0JC5waXBlKFxuICAgICAgc3dpdGNoTWFwKHN1Ym1pdCA9PiAoc3VibWl0ID8gY29udHJvbENoYW5nZXMkLnBpcGUoc3RhcnRXaXRoKHRydWUpKSA6IE5FVkVSKSlcbiAgICApO1xuXG4gICAgLy8gb24gcmVzZXQsIGNsZWFyIENvbXBvbmVudFJlZiBhbmQgY3VzdG9tQW5jaG9yRGVzdHJveUZuXG4gICAgdGhpcy5yZXNldCQucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xlYXJSZWZzKCkpO1xuXG4gICAgbWVyZ2UoY2hhbmdlc09uQXN5bmMkLCBjaGFuZ2VzT25CbHVyJCwgY2hhbmdlc09uU3VibWl0JCwgdGhpcy5zaG93RXJyb3IkKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudmFsdWVDaGFuZ2VzKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRFcnJvcih0ZXh0OiBzdHJpbmcsIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycykge1xuICAgIGlmICghdGhpcy5yZWYpIHtcbiAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5PENvbnRyb2xFcnJvckNvbXBvbmVudD4oXG4gICAgICAgIHRoaXMubWVyZ2VkQ29uZmlnLmNvbnRyb2xFcnJvckNvbXBvbmVudFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVmID0gdGhpcy5hbmNob3IuY3JlYXRlQ29tcG9uZW50PENvbnRyb2xFcnJvckNvbXBvbmVudD4oZmFjdG9yeSk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5yZWYuaW5zdGFuY2U7XG5cbiAgICBpZiAodGhpcy5jb250cm9sRXJyb3JzVHBsKSB7XG4gICAgICBpbnN0YW5jZS5jcmVhdGVUZW1wbGF0ZSh0aGlzLmNvbnRyb2xFcnJvcnNUcGwsIGVycm9yLCB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UudGV4dCA9IHRleHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29udHJvbEVycm9yc0NsYXNzKSB7XG4gICAgICBpbnN0YW5jZS5jdXN0b21DbGFzcyA9IHRoaXMuY29udHJvbEVycm9yc0NsYXNzO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sRXJyb3JBbmNob3IgJiYgdGhpcy5tZXJnZWRDb25maWcuY29udHJvbEVycm9yQ29tcG9uZW50QW5jaG9yRm4pIHtcbiAgICAgIHRoaXMuY3VzdG9tQW5jaG9yRGVzdHJveUZuID0gdGhpcy5tZXJnZWRDb25maWcuY29udHJvbEVycm9yQ29tcG9uZW50QW5jaG9yRm4oXG4gICAgICAgIHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAodGhpcy5yZWYuaG9zdFZpZXcgYXMgRW1iZWRkZWRWaWV3UmVmPGFueT4pLnJvb3ROb2Rlc1swXSBhcyBIVE1MRWxlbWVudFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhwbGljaXQgc2hvd2luZyBvZiBhIGNvbnRyb2wgZXJyb3IgdmlhIHNvbWUgY3VzdG9tIGFwcGxpY2F0aW9uIGNvZGUuXG4gICAqL1xuICBzaG93RXJyb3IoKTogdm9pZCB7XG4gICAgdGhpcy5zaG93RXJyb3IkLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsaWNpdCBoaWRpbmcgb2YgYSBjb250cm9sIGVycm9yIHZpYSBzb21lIGN1c3RvbSBhcHBsaWNhdGlvbiBjb2RlLlxuICAgKi9cbiAgaGlkZUVycm9yKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0RXJyb3IobnVsbCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuY2xlYXJSZWZzKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLm1lcmdlZENvbmZpZy5ibHVyUHJlZGljYXRlKHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJSZWZzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1c3RvbUFuY2hvckRlc3Ryb3lGbikge1xuICAgICAgdGhpcy5jdXN0b21BbmNob3JEZXN0cm95Rm4oKTtcbiAgICAgIHRoaXMuY3VzdG9tQW5jaG9yRGVzdHJveUZuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICB0aGlzLnJlZi5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMucmVmID0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgdmFsdWVDaGFuZ2VzKCkge1xuICAgIGNvbnN0IGNvbnRyb2xFcnJvcnMgPSB0aGlzLmNvbnRyb2wuZXJyb3JzO1xuICAgIGlmIChjb250cm9sRXJyb3JzKSB7XG4gICAgICBjb25zdCBbZmlyc3RLZXldID0gT2JqZWN0LmtleXMoY29udHJvbEVycm9ycyk7XG4gICAgICBjb25zdCBnZXRFcnJvciA9IHRoaXMuY3VzdG9tRXJyb3JzW2ZpcnN0S2V5XSB8fCB0aGlzLmdsb2JhbEVycm9yc1tmaXJzdEtleV07XG4gICAgICBpZiAoIWdldEVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dCA9IHR5cGVvZiBnZXRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGdldEVycm9yKGNvbnRyb2xFcnJvcnNbZmlyc3RLZXldKSA6IGdldEVycm9yO1xuICAgICAgaWYgKHRoaXMuaXNJbnB1dCkge1xuICAgICAgICB0aGlzLmhvc3QubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Vycm9yLXRhaWxvci1oYXMtZXJyb3InKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RXJyb3IodGV4dCwgY29udHJvbEVycm9ycyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlZikge1xuICAgICAgaWYgKHRoaXMuaXNJbnB1dCkge1xuICAgICAgICB0aGlzLmhvc3QubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Vycm9yLXRhaWxvci1oYXMtZXJyb3InKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RXJyb3IobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlQW5jaG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnRyb2xFcnJvckFuY2hvcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEVycm9yQW5jaG9yLnZjcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb250cm9sRXJyb3JBbmNob3JQYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xFcnJvckFuY2hvclBhcmVudC52Y3I7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZjcjtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRDb25maWcoKTogRXJyb3JUYWlsb3JDb25maWcge1xuICAgIHJldHVybiB7XG4gICAgICAuLi57XG4gICAgICAgIGJsdXJQcmVkaWNhdGUoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcgfHwgZWxlbWVudC50YWdOYW1lID09PSAnU0VMRUNUJztcbiAgICAgICAgfSxcbiAgICAgICAgY29udHJvbEVycm9yQ29tcG9uZW50OiBEZWZhdWx0Q29udHJvbEVycm9yQ29tcG9uZW50XG4gICAgICB9LFxuICAgICAgLi4udGhpcy5jb25maWdcbiAgICB9O1xuICB9XG59XG4iXX0=